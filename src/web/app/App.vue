<script lang="ts" setup>
import { onBeforeMount, ref } from "vue";

import {
    AiResponseQuery,
    BpmnFile,
    BpmnFileQuery,
    GetBpmnFilesCommand,
    GetPromptsCommand,
    GetTemplatesCommand,
    LogErrorCommand,
    LogInfoCommand,
    MiranumCopilotQuery,
    Prompt,
    PromptQuery,
    Template,
    TemplateQuery,
} from "../../shared";
import { createResolver } from "@/utils";

import {
    CopilotState,
    DefaultViewState,
    DocumentationViewState,
    initVsCodeApi,
    MissingStateError,
    VsCode,
} from "./vscode";
import SidebarMenu from "./components/SidebarMenu.vue";
import DefaultView from "@/views/DefaultView.vue";
import DocumentationView from "@/views/DocumentationView.vue";

//
// Vars
//
// eslint-disable-next-line @typescript-eslint/naming-convention
declare const process: { env: { NODE_ENV: string } };

let vscode: VsCode;
if (process.env.NODE_ENV === "development") {
    vscode = initVsCodeApi("development");
} else {
    vscode = initVsCodeApi("production");
}

let isInitialized = false;

/* The prompt entered by the user. */
let userPrompt = ref<Prompt<string>>(new Prompt<string>(""));
/* The response generated by the language model. */
let aiResponse = ref("");
/* The BPMN file selected by the user. */
let selectedBpmn = ref<BpmnFile | undefined>();

/* The predefined prompts sent by the backend. */
const prompts = ref<Map<string, Prompt<boolean>[]>>();
/* The list of BPMN files in the workspace sent by the backend. */
const bpmnFiles = ref<BpmnFile[]>([]);
const templates = ref<Map<string, Template[]>>();

/* The current view. */
const viewState = ref("DefaultView");
/* Whether the webview is loading. */
const loading = ref(true);
/* Whether the sidebar is shrunk. */
let shrunk = ref(false);

//
// Logic
//

const promptsResolver = createResolver<Map<string, Prompt<boolean>[]>>();
const bpmnFilesResolver = createResolver<BpmnFile[]>();
const templateResolver = createResolver<Map<string, Template[]>>();

/**
 * The "main" method.
 * We wait until the webview is fully loaded.
 * Then we send a message to the backend to inform that it is fully loaded.
 * The backend will send then the initial data.
 */
onBeforeMount(async () => {
    // Add event listener for incoming messages
    window.addEventListener("message", receiveMessage);

    try {
        const state = vscode.getState(); // Throws MissingStateError if no state is available
        // TODO: Ask backend if there were unsuccessful requests

        if (state instanceof DefaultViewState) {
            setDefaultViewData(state);
        } else if (state instanceof DocumentationViewState) {
            setDocumentationViewData(state);
        }

        loading.value = false;
    } catch (error) {
        if (error instanceof MissingStateError) {
            isInitialized = true;

            vscode.postMessage(new GetBpmnFilesCommand());
            vscode.postMessage(new GetPromptsCommand());
            vscode.postMessage(new GetTemplatesCommand());

            const [bpmnFilesData, promptsData, templatesData] = await Promise.all([
                bpmnFilesResolver.wait(),
                promptsResolver.wait(),
                templateResolver.wait(),
            ]);

            loading.value = false;

            const newState = new DefaultViewState(
                templatesData ?? new Map(),
                bpmnFilesData ?? [],
                promptsData ?? new Map(),
                userPrompt.value ?? new Prompt<string>(""),
                aiResponse.value,
                bpmnFilesData ? bpmnFilesData[0] : new BpmnFile("", "", ""),
            );
            vscode.setState(newState);

            postMessage(new LogInfoCommand("Webview was initialized."));
        } else {
            const message = error instanceof Error ? error.message : `${error}`;
            postMessage(new LogErrorCommand(message));
        }
    }
});

/**
 * Handle incoming messages.
 * @param message The incoming message
 */
function receiveMessage(message: MessageEvent<MiranumCopilotQuery>): void {
    const query = message.data;

    switch (true) {
        case query.type === "TemplateQuery": {
            const templateQueryData = (query as TemplateQuery).templates;
            if (isInitialized) {
                templateResolver.done(templateQueryData);
            } else {
                templates.value = templateQueryData;
            }
            break;
        }
        case query.type === "BpmnFileQuery": {
            const bpmnFileQueryData = (query as BpmnFileQuery).bpmnFiles;
            if (isInitialized) {
                bpmnFilesResolver.done(bpmnFileQueryData);
            } else {
                bpmnFiles.value = bpmnFileQueryData;
            }
            break;
        }
        case query.type === "PromptQuery": {
            const promptQueryData = (query as PromptQuery).prompts;
            if (isInitialized) {
                promptsResolver.done(promptQueryData);
            } else {
                prompts.value = promptQueryData;
            }
            break;
        }
        case query.type === "AiResponseQuery": {
            aiResponse.value = (query as AiResponseQuery).response;
            const defaultViewState = vscode.getState(
                "DefaultViewState",
            ) as DefaultViewState;
            vscode.setState(
                new DefaultViewState(
                    defaultViewState.templates,
                    defaultViewState.bpmnFiles,
                    defaultViewState.prompts,
                    defaultViewState.currentPrompt,
                    aiResponse.value,
                    defaultViewState.selectedBpmnFile,
                ),
            );
            break;
        }
    }

    isInitialized = false;
}

function setDefaultViewData(state: DefaultViewState) {
    templates.value = state.templates;
    bpmnFiles.value = state.bpmnFiles;
    prompts.value = state.prompts;
    userPrompt.value = state.currentPrompt;
    aiResponse.value = state.aiResponse;
    selectedBpmn.value = state.selectedBpmnFile;
}

function setDocumentationViewData(state: DocumentationViewState) {
    templates.value = state.templates;
    bpmnFiles.value = state.bpmnFiles;
    prompts.value = state.prompts;
    selectedBpmn.value = state.selectedBpmnFile;
}

function handleSidebarToggle(isVisible: boolean) {
    shrunk.value = isVisible;
}

function handleSelectedPrompt(prompt: Prompt<boolean>) {
    viewState.value = "DefaultView";
    userPrompt.value = new Prompt(
        prompt.prompt,
        prompt.process ? "" : undefined,
        prompt.form ? "" : undefined,
    );

    vscode.updateState({
        currentPrompt: userPrompt.value,
    });
}

function switchToDocumentationView() {
    viewState.value = "DocumentationView";
    vscode.updateState({ viewState: viewState.value });
}

function updateSelectedBpmn(bpmnFile: BpmnFile) {
    // FIXME: Instead of Child -> Parent -> Child, it should be Child -> Child
    selectedBpmn.value = bpmnFile;
}
</script>

<template>
    <main :class="{ shrunk: shrunk }">
        <DefaultView
            v-if="viewState === 'DefaultView'"
            :ai-response="aiResponse"
            :bpmn-files="bpmnFiles"
            :loading="loading"
            :prompt="userPrompt.prompt"
            :selected-bpmn="selectedBpmn"
            @update-selected-bpmn="updateSelectedBpmn"
        />
        <DocumentationView
            v-if="viewState === 'DocumentationView'"
            :loading="loading"
            :process-dropdown="bpmnFiles"
            :selected-bpmn="selectedBpmn"
            @send-prompt="sendPrompt"
        />
    </main>
    <SidebarMenu
        :prompts="prompts"
        @sidebar-toggled="handleSidebarToggle"
        @prompt-selected="handleSelectedPrompt"
        @documentation-selected="switchToDocumentationView"
    />
</template>

<style scoped>
main {
    display: grid;
    grid-template-areas:
        "input"
        "output";
    gap: 40px;

    width: 800px;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
}
</style>
